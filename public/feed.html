<script>
    // add link to groundtalk posts at end of posts?
    
    // figure out ids and nesting convention

    // figure out how to display message with specific url

    // authentication / sign -in

    // save mastodon and url preferneces locally in cache

    // social media client, general tool

    // low energy context

    // enter search query, pull from twitter api all searches for the thing, minimal load
    
    // image compressor

    // extensions

    // listen for event on twitter post (Find the event), on mastodon post

    // then open the windows, same for groundtalk

    // 1A1A1A -- handle server side

    // groundtalk.land/1 < getMessage "1", netlify function that returns html

    // image upload with squoosh
</script>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://unpkg.com/htmx.org@1.8.6"></script>
<script src="https://unpkg.com/hyperscript.org@0.9.7"></script>
</head>

<body onload="loadUserDetails()" style="max-width: 100%; width: 800px; margin: auto;">
<!-- <div onclick="location.href='/'" style="display: none; position: relative; max-width: 640px; margin: auto; text-align: center; cursor: pointer;" >
    <img src="./header.svg" style="width: 640px; max-width: 100%";>
        <div class="header" style="position: absolute; top: 50%;
        left: 50%;
        transform: translate(-50%, -50%); width: 100%;">
      <h2 style="font-weight: 400;">A cooperative social network,<br>to realize our worlds.</h2>
      <h1 style="margin-top: 15px;">groundtalk.land</h1>
      </div>
    </div>
<br> -->

<div style="margin-left: auto; width: fit-content;">
    <form style="text-align: right;" id="signInForm" hx-post="/.netlify/functions/signInWithOtp" hx-target="#signInUpdate" hx-trigger="submit">
     <p style="margin-bottom: 0px;"><strong>Sign in with magic link</strong></p>
    <label style="margin-top: 5px; display: block;">Email</label>
    <input type="email" name="email" required>
    <br>
    <!-- <a href="" hx-post="/.netlify/functions/forgotPassword" hx-trigger="click">Forgot password?</a>
    <br>
    <label style="margin-top: 10px; display: block;">Password</label>
    <input name="password"><br> -->
    <button type="submit" style="display: block; margin: 10px 0 10px auto">Send Magic Link</button>
    <span id="signInUpdate"></span>
    </form>
</div>

<div style="margin: auto">
            <!-- <label>Posting as ...</label><input name="author">
            <p class="center"><em>Enter new post</em></p>
                <br><br> -->
        <form class="center" style="" hx-post="/.netlify/functions/postMessage" hx-target="#feed" hx-swap="afterbegin" hx-trigger="submit" _="on htmx:afterSwap call logData(event, swap)">
            <textarea name="txt" style="width: 350px; height: 100px"></textarea>
            <input id="topLevelId" name="id" value="" style="display: none">
            <input name="by" class="by" id="by_main" style="display: none;">
            <!-- <p style="text-align: center;"><em>Crosspost to:</em></p> -->
            <div style="display: flex; margin-top: 10px;">
                <div class="checkbox"><input type="checkbox" value="Twitter"><label>Post to Twitter</label></div>
                <div class="checkbox"><input type="checkbox" value="Mastodon" style="margin-left: 20px;"><label>Post to Mastodon</label></div>
            </div>
        <button style="margin-left: auto; display: block;">Submit</button>
        </form>
        <hr style="max-width: 350px; margin: 30px auto;">
        <div id="feed" class="center">

        </div>
</div>

</body>
<script>

    function loadUserDetails() {
        if (localStorage.getItem('email') && localStorage.getItem('email') != "undefined") {
            document.getElementById('signInForm').innerHTML = `<p class="user">${localStorage.getItem('email')}</p>`
            document.getElementById('by_main').setAttribute('value', localStorage.getItem('username'));
        }

        else {
            auth()
        }
    }

    function auth() {
        if (window.location.href.includes('magiclink')) {

        console.log(window.location);
        let params_url = window.location.href.replace('#', '?')
        console.log(params_url);
        let params = new URLSearchParams(params_url);
        console.log([...params])
        console.log([...params][0][1]);

        // console.log([...params.[2].[1]])

        const xhr = new XMLHttpRequest();

        // adding timestamp value as query parameter
        const url = `/.netlify/functions/signInWithRefreshToken/?refresh_token=${params.get('refresh_token')}`

        xhr.open("GET", url);

        xhr.onload = function () {

            if (xhr.status == 200) {

                let response = JSON.parse(xhr.response);

                localStorage.setItem('id', response.id);
                localStorage.setItem('email', response.email);
                localStorage.setItem('username', response.username)
                localStorage.setItem('access_token', response.access_token);

                document.getElementById('signInForm').innerHTML = `<p class="user">${localStorage.getItem('email')}</p>`

            }
        };
        xhr.onerror = function () {
            // ...handle/report error...
        };

        xhr.send();

        }

    }

    function toggleReply(event) {

        // If the button currently says "Reply" and is clicked, we will handle that accordingly.
        // Otherwise, if the button currently says "Cancel reply", we'll go down to the else statement below and handle accordingly.
        if (event.srcElement.innerText == "Reply") {

        // We are preparing a comment reply form, which will include pre-populating the "ref" value for the reply.
        let ref;
        
        // The "ref" value is a chain going back to a top-level message.
        // 2023-07-23T09:44:38.787+00:00-1 is the first reply to a top-level message.
        // 2023-07-23T09:44:38.787+00:00-2 is the second reply to a top-level message.
        // 2023-07-23T09:44:38.787+00:00-1-1 is the first reply to the message where ref=2023-07-23T09:44:38.787+00:00-1
        // 2023-07-23T09:44:38.787+00:00-1-2 is the second reply to the message where ref=2023-07-23T09:44:38.787+00:00-2
        // 2023-07-23T09:44:38.787+00:00-1-1-1 is the first reply to the message where ref=2023-07-23T09:44:38.787+00:00-1-1

        // to get the ref value for the new reply, we first need the ref value for the message we're replying to
        let parent_ref;
        
        // we also need to check the number of siblings in the chain — the Nth number of replies to the same message (starting at index of 1)

        let siblings;

        // if we're replying to a top-level comment, the parent_ref value will be null
        // we also need to handle this case a little carefully with the siblings value
        if (event.srcElement.parentNode.getAttribute('ref') == "null") {
            console.log('top level message')

            // since there is no ref value for this message, we will use it's id instead
            parent_ref = event.srcElement.parentNode.id;

             // to determine the amount of siblings in this chain, we only want to count all the siblings on the first level — e.g. only those with a single hyphen
             let nodeList = document.querySelectorAll(`[ref^="${parent_ref}"]`);

            //  however, this will return a list of ALL the messages with reference values that begin with the parent_ref — including those on the second, third, fourth levels.
            // So we want to use a regex to find only the siblings on the first level — by filtering the nodeList above for values that end in a :00-[number]
            const regex = new RegExp(/:00-\d+$/i);

            console.log(nodeList);

            console.log(Array.from(nodeList));
            
            // console.log(Array.from(nodeList).filter(node => regex.test(node)))

            let sibs = Array.from(nodeList).filter(node => regex.test(node.attributes['ref'].nodeValue) == true);

            for (i = 0; i < nodeList.length; i++) {
                console.log(nodeList[i].attributes['ref'].nodeValue);
                console.log(regex.test(nodeList[i].attributes['ref'].nodeValue))
            }

            console.log(sibs);

            // console.log(siblingNodeList)


            // console.log(array.from(document.querySelectorAll(`[ref^="${parent_ref}"][ref$=":00-"]`)).filter(node => node.length ))
            siblings = sibs.length + 1;
        }
        else {
            console.log('not top level message');
            parent_ref = event.srcElement.parentNode.getAttribute('ref');
            console.log(parent_ref);
            console.log(document.querySelectorAll(`[ref^="${parent_ref}"]`));
            siblings = document.querySelectorAll(`[ref^="${parent_ref}"]`).length;
            console.log(siblings);
        }

        // Finally, we set the ref value for the new message reply based on the siblings found in the chain above

        ref = parent_ref + "-" + siblings
        console.log(ref);


        // Now we create an element which will be inserted into the DOM and contains the form and textarea for the new message, including a hidden input value with the "ref" for the message reply — that we determined above
        let reply = document.createElement('div');

        reply.innerHTML = `<form hx-post="/.netlify/functions/postMessage" hx-trigger="submit" _="on htmx:afterSwap call logReply(event, swap)">
            <textarea name="txt"></textarea><br>
            <input value=${ref} name="ref" style="display: none">
            <input id="by_reply" class="by" name="by" value="${localStorage?.getItem('username')}" style="display: none">
            <button type="submit">Submit reply</button>
            <br>
            </form>`;

        event.srcElement.parentNode.insertAdjacentElement('afterend', reply);

        // after inserting an element via the DOM, we have to run htmx.process() for htmx to work on the newly inserted element.  documentation from htmx here: https://htmx.org/api/
        htmx.process(document);

        // We change the reply button text to "Cancel reply", for toggling purposes — so when it's clicked again, it will toggle as expected
        event.srcElement.innerText = "Cancel reply"

        }
        else {

            let reply = event.srcElement.parentNode.nextSibling;

            console.log(reply);

            reply.remove();

            event.srcElement.innerText = "Reply"
        }


    }

   async function checkForSignIn() {

        const supabaseUrl = process.env.SUPABASE_URL;
        const supabaseKey = process.env.SUPABASE_API_KEY;
        const supabase = createClient(supabaseUrl, supabaseKey);

        const { data, error } = await supabase.auth.getSession()

        if (error) {
            return {
            statusCode: 500,
            body: JSON.stringify(error),
            };
        } else {
            console.log(JSON.stringify(data))

            return {
                statusCode: 200,
                body: (JSON.stringify(data))
            };
        }

        // const searchParams = new URLSearchParams(window.location.search);
        // const token = searchParams.get('token');

        // Get the user session and data using the magic link token
        const getSessionData = async () => {
            try {
                const { user, session, error } = await supabase.auth.api.getUserByCookie(magicLinkToken);
                if (error) {
                    console.error('Error getting session:', error);
                } else {
                    console.log('User:', user);
                    console.log('Session:', session);
                }
            } catch (error) {
                console.error('Error getting session:', error);
            }
        };

        // Call the getSessionData function to retrieve the user session and data
        getSessionData();
    }

    function loadCacheThenGetMessages() {

        // ts = timestamp
        // we will append this as a query parameter to the GET request, to indicate which messages (if any) to retrieve in the backend
        // because some messages may already be cached locally, as a way of lowering the amount of requests and repeated data transfers
        let id = 0;

        if (localStorage?.cache) {

            // setting the feed to all of the messages in the cache
            document.getElementById('feed').innerHTML = localStorage?.cache;

            // Set the timestamp value equal to the timestamp value of the latest message in the cache.
            id = document.getElementsByClassName("post")[0].id;
        }

            const xhr = new XMLHttpRequest();

            // adding timestamp value as query parameter
            const url = `/.netlify/functions/getMessages/?id=${id}`

            xhr.open("GET", url);

            xhr.onload = function () {
                console.log(xhr.response);

                if (xhr.response) {

                // appending the messages retrieved from the DB to the top of the feed
                document.getElementById('feed').innerHTML = xhr.response + document.getElementById('feed').innerHTML;
                // addReply();

                // and updating the message cache with the updated version of the feed
                localStorage.setItem('cache', document.getElementById('feed').innerHTML);
                }
            };
            xhr.onerror = function () {
                // ...handle/report error...
            };

            xhr.send();

            let refs = document.querySelectorAll(`div[ref]:not([ref="null"])`);

            console.log();

    //         for (i = 0; i < refs.length; i++) {

    //             // drop after last hyphen, substring
    //             // queryselect ref
    //             // take text value
    //             // include

    //             let parent = document.createElement('button');
    //             parent.innerText = 'Show parent'
    //             parent.onclick =     function showParent(event) {
    //     console.log(event)
    //     console.log(event.srcElement.nextSibling.attributes['ref'].nodeValue);
    // }

    //             let children = document.createElement('button');
    //             children.innerText = 'Show children'
    //             children.onclick =     function showChildren(event) {
    //     console.log(event)
    //     console.log(event.srcElement.previousSibling.attributes['ref'].nodeValue);
    // }

    //             children.style.marginBottom = "10px";
    //             children.style.display = "block";

    //             refs[i].insertAdjacentElement('beforebegin', parent);
    //             refs[i].insertAdjacentElement('afterend', children);
    //         }

    }

    function showParent(event,parentRef) {

    if (event.srcElement.innerText == "Show parent") {
        console.log(parentRef)
        console.log(event);
        let list = document.createElement('ul');
        let p = document.createElement('p');

        // find all nodes with ref value that starts with thisref

        let parent = document.querySelector(`[ref="${[parentRef]}"], [id="${[parentRef]}"]`);
        console.log(parent);

        p.innerHTML = `<a href="#${parent.id}">${parent.children['2'].innerText}</a>`

        event.srcElement.insertAdjacentElement('afterend', p);
        event.srcElement.innerText = "Minimize";

        // useful if we want to get a tree of parents
        // nodeList.forEach(div => {
        //     console.log(div);
        //     console.log(div.children['2']);
        //     var li = document.createElement('li');
        //     li.innerText = div.children['2'].innerText;
        //     list.appendChild(li);
        // })

    }
    else {
        console.log('minimize')
        event.srcElement.innerText = "Show parent";
        event.srcElement.nextSibling.remove();
    }

}

    function showChildren(event,thisRef) {

        if (event.srcElement.innerText == "Show children") {
            console.log(thisRef)
            console.log(event);
            let list = document.createElement('ul');

            // find all nodes with ref value that starts with thisref

            let nodeList = document.querySelectorAll(`[ref^="${thisRef}-"]`);
            console.log(nodeList);

            let sortedList = [...nodeList].sort((a, b) => (a.attributes['ref'].nodeValue.substring(30) > b.attributes['ref'].nodeValue.substring(30)) ? 1 : -1);

            console.log(sortedList);


            sortedList.forEach(div => {
                console.log(div);
                console.log(div.children['2']);
                var li = document.createElement('li');
                li.innerHTML = `<a href="#${div.id}">${div.children['2'].innerText}</a>`

                // here we are counting the number of hyphens in the ref value, to get the level of "nesting" of the message.
                // first-level reply to a parent message will have a level of 1, a reply to a first-level reply will have a level of 2
                let level = div.getAttribute('ref').split("-").length - 3;
                console.log(level);

                // now we calculate the indent for nested replies, which we will include as marginLeft in the styling
                let indent = (level - 1) * 20;

                li.style.marginLeft = indent + "px";
                list.appendChild(li);
            })

            console.log(list);

            event.srcElement.insertAdjacentElement('afterend', list);
            event.srcElement.innerText = "Minimize";
        }
        else {
            console.log('minimize')
            event.srcElement.innerText = "Show children";
            event.srcElement.nextSibling.remove();
        }

    }


    loadCacheThenGetMessages();

    function logData(event, swap) {
        console.log('logdata');
            console.log(swap);
            console.log(event);
            const xhr = event.detail.xhr;
            console.log(xhr);
            updateTopLevelId();
    }   

    function sortList(ul){
    var new_ul = ul.cloneNode(false);

    // Add all lis to an array
    var lis = [];
    for(var i = ul.childNodes.length; i--;){
        if(ul.childNodes[i].nodeName === 'LI')
            lis.push(ul.childNodes[i]);
    }

    // Sort the lis in descending order
    lis.sort(function(a, b){
       return parseInt(b.childNodes[0].data , 10) - 
              parseInt(a.childNodes[0].data , 10);
    });

    // Add them into the ul in order
    for(var i = 0; i < lis.length; i++)
        new_ul.appendChild(lis[i]);
    ul.parentNode.replaceChild(new_ul, ul);
}

//     htmx.logger = function(elt, event, data) {
//     if(console) {
//         console.log(event, elt, data);
//     }
// }

htmx.on("htmx:afterSwap", function(evt) {
    console.log('after swap')
    console.log(evt);
    console.log(evt.detail.requestConfig.parameters.txt);
    console.log(evt.detail.requestConfig.parameters.id);

    // if (typeof(evt.detail.requestConfig.parameters.id) == "number") {

    // updateTopLevelId(evt.detail.requestConfig.parameters.id);

    // }

    if (document.querySelector('input[value="Twitter"]').checked || document.querySelector('input[value="Mastodon"]').checked) {

        console.log('crosspost!')

        crosspost(evt.detail.requestConfig.parameters.txt)

    }
    // myJavascriptLib.init(evt.detail.elt);
});

//  this function below is a work-in-progress, for local automated cross-posting

// for extension when browsing other sites: css and html injection when browsing walled gardens like tiwtter and linkedin and facebook to crosspost out and mastodon


// for uploading to ground talk:
// integer pk, natural id which is url that contains post data
// gah integer pk makes sense (esp for many-to-many like replies), but for offline / local-first / distributed then uuidv7 makes sense
// automatically compress images on uploading
// choice of "upload to groundtalk"
// email notifications on daily basis
// implement replies
// show where you are posting from on groundtalk with your author id?



// authenticate groundtalk
// authenticate mastodon?


function crosspost(msg) {
    
    if (document.querySelector('input[value="Twitter"]').checked) {
        var twitter = window.open(`https://twitter.com/intent/tweet?text=${msg}`, 'twitter','width=500,height=500');

    }
    
    if (document.querySelector('input[value="Mastodon"]').checked) {
        
        let instance_url = "https://kolektiva.social"
        var mastodon = window.open(`https://kolektiva.social/share?text=${msg}`, 'mastodon','width=500,height=500');

    }
        
        // let instance_url = "https://kolektiva.social"

        // // open twitter window with post contents
        // var twitter = window.open(`https://twitter.com/intent/tweet?text=${msg}`, 'twitter','width=500,height=500');

        // var mastodon = window.open(`https://kolektiva.social/share?text=${msg}`, 'mastodon','width=500,height=500');


        // open Mastodon window with post contents

        setTimeout(function() {

        

        // twitter.document.querySelector(`[data-testid="tweetButton"] > .css-901oao > .css-901oao > .css-901oao`).click()

        // twitter.querySelector("div[data-testid='tweetButton'] > div > span > span").click();

        twitter.close();

        }, 10000)

        twitter.onload = function() {

        // var tweetInput = twitterWindow.document.querySelector('[name="tweet"]');
        // tweetInput.value = text;

        // alert('load')

        // Find the Tweet button and click it
        // var tweetButton = twitterWindow.document.querySelector('[data-testid="tweetButton"]');
        // tweetButton.click();
        }


//         function composeTweet(text) {
//   // Open a new window
//   var twitterWindow = window.open("https://twitter.com/compose/tweet", "_blank");

//   // Wait for the window to load
//   twitterWindow.onload = function() {
//     // Find the text input field and set its value
//     var tweetInput = twitterWindow.document.querySelector('[name="tweet"]');
//     tweetInput.value = text;

//     // Find the Tweet button and click it
//     var tweetButton = twitterWindow.document.querySelector('[data-testid="tweetButtonInline"]');
//     tweetButton.click();
//   };
// }

// Usage example
// composeTweet("Hello, world!");




        // alert("page fully loaded");

        // let tweetButton = null;

        // twitter.document.querySelectorAll(`data-testid[tweetButton]`)[0].onload() = (event) => {
        //     alert('hey');
        // }

        // while (tweetButton == null) {
        //     if (twitter.document.querySelectorAll(`data-testid[tweetButton]`)[0]) {
        //         twitter.console.log('not null');
        //         tweetButton = twitter.document.querySelectorAll(`data-testid[tweetButton]`)[0];
        //         twitter.alert('not null');
        //     }
        // }

        // twitter.onload = (event) => {
        //     console.log("page fully loaded");
        // };

        // twitter.addEventListener("load", (event) => {

        //     alert("page fully loaded");

        // })
    

            // twitter.document.querySelectorAll(`data-testid="tweetButton"`)[0].click
        // twitter.document.onload()

        // getElementsByClassName("public-DraftStyleDefault-block public-DraftStyleDefault-ltr")[0].innerHTML = `<span data-offset-key="fjigd-0-0"><span data-text="true">test</span></span>`

    }

// function text() {


//     // openTab().then({
//     //     function(){
//     //         twitter.document.getElementsByClassName("public-DraftStyleDefault-block public-DraftStyleDefault-ltr")[0].firstChild.click();
//     //     twitter.document.getElementsByClassName("public-DraftStyleDefault-block public-DraftStyleDefault-ltr")[0].firstChild.focus();


//     //     twitter.document.getElementsByClassName("public-DraftStyleDefault-block public-DraftStyleDefault-ltr")[0].innerHTML = `<span data-offset-key="fjigd-0-0"><span data-text="true">test</span></span>`
//     //     }
//     // })

// };

    // function replaceHTML() {
    //     twitter.document.getElementsByClassName("public-DraftStyleDefault-block public-DraftStyleDefault-ltr")[0].firstChild.click();
    //     twitter.document.getElementsByClassName("public-DraftStyleDefault-block public-DraftStyleDefault-ltr")[0].firstChild.focus();


    //     twitter.document.getElementsByClassName("public-DraftStyleDefault-block public-DraftStyleDefault-ltr")[0].innerHTML = `<span data-offset-key="fjigd-0-0"><span data-text="true">test</span></span>`

    // }
</script>

<style>
    .center {
        margin: auto;
        width: fit-content;
        display: block;
    }
    div.post {
        background: lightyellow; padding: 1em; border: solid 1px darkgrey; border-radius: 10px; width: 300px; max-width: 100%; margin-bottom: 0.75em;
    }
    p.by {
        font-weight: 600;
    }
    p.ts {
        font-style: italic;
        font-size: 12px;
    }
    p.ref {
        display: none;
    }
    @media only screen and (max-width: 600px) {

    .header h2{
      font-size: 1.3em;
      line-height: normal;
    }
    .header h1{
      font-size: 1.7em;
      line-height: normal;
      margin-top: -11px !important;
    }
  }
  button {
    display: block;
    margin-bottom: 10px;
  }

  .checkbox > label {
    margin-left: 5px;
  }

  .user {
    font-weight: bold;
  }
</style>